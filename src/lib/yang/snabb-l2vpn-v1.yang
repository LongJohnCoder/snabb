module snabb-l2vpn-v1 {
  namespace snabb:l2vpn;
  prefix l2vpn;

  import ietf-inet-types { prefix inet; }
  import ietf-yang-types { prefix yang; }

  organization "SWITCH";
  contact "Alexander Gall <alexander.gall@switch.ch>";
  description
    "Configuration for the Snabb Switch L2VPN Program";

  revision 2019-02-03 {
    description
      "Initial revision.";
  }

  container l2vpn-config {
    description
      "Configuration for the Snabb L2VPN program.";

    leaf instance-name {
      type string;
      mandatory true;
      description
        "The name of the instance of the Snabb L2VPN program.  This is used to
         distinguish different instances running on the same system.";
    }

    container luajit {
      description
        "LuaJIT runtime settings";

      leaf-list option {
        type string;
        description
          "A LuaJIT runtime option.";
      }
      container dump {
        leaf enable {
          type boolean;
          default false;
          description
            "Whether to enable the JIT dump facility.";
        }
        leaf option {
          type string;
          description
            "Options for the LuaJIT trace dumper.";
        }
        leaf file {
          type string;
          default "/tmp/dump";
          description
            "Location of the LuaJIT dump file.  The file name may contain the
             string '%p', which will be replaced by the ID of the
             worker process in which the LuaJIT instance is executing";
        }
      }
    }

    container snmp {
      leaf enable {
        type boolean;
        description
          "Whether to enable SNMP. This will instantiate MIB objects for
           interfaces and pseudowires";
      }
      leaf interval {
        type uint8;
        default 5;
        description
          "The interval at which the SNMP objects will be synchronized with the
           state of the program.";
      }
    }

    grouping interface-address-families {
      container address-families {
        container ipv4 {
          leaf address {
            type inet:ipv4-address;
            description
              "The IPv4 address assigned to the L3 interface, without netmask.";
          }
          leaf next-hop {
            type inet:ipv4-address;
            description
              "The IPv4 next-hop address used for all packets leaving the L3
               interface. The address is assumed to be on-net.";
          }
        }
        container ipv6 {
          leaf address {
            type inet:ipv6-address;
             description
              "The IPv6 address assigned to the L3 interface, without netmask.";
          }
          leaf next-hop {
            type inet:ipv6-address;
            description
              "The IPv6 next-hop address used for all packets leaving the L3
               interface. The address is assumed to be on-net.";
          }
        }
      }
    }

    list interface {
      description
        "A list of interface definitions.";

      key "name";
      min-elements 1;

      leaf name {
        type string;
        mandatory true;
        description
          "The name of the interface. This name appears as the <ifName> and
           <ifDescr> SNMP OIDs";
      }

      leaf description {
        type string;
        description
          "A free-form description of the function of the interface. This string
           appears as the <ifAlias> SNMP OID";
      }

      container driver {
        leaf path {
          type string;
          mandatory true;
          description
            "The path of the Snabb driver to use for the interface in 'dotted'
             notation, e.g. 'apps.intel_mp.intel_mp'";
        }
        leaf name {
          type string;
          mandatory true;
          description
            "The name of the driver object to instantiate for the interface,
             relative to <path> (i.e. 'require(path)[name]'";
        }
        leaf config {
          type string;
          description
            "A string containing a literal Lua expression.  The result of the
             evaluation of this expression is passed as argument to
             the call of the driver's new() method";
        }
        leaf extra-config {
          description
            "A string containing a literal Lua expression which must evaluate to a
             table.  If the expression given in <config> is a table,
             it is merged with this table. If a key is present in both
             tables, the one from <extra-config> takes precedence.";
          type string;
        }
      }

      container mirror {
        description
          "Traffic mirror configuration for the interface.";

        leaf rx {
          type boolean;
          description
            "Whether to enable mirroring for incoming packets.";
        }
        leaf tx {
          type boolean;
          description
            "Whether to enable mirroring for outgoing packets.";
        }
        leaf type {
          type enumeration {
            enum "tap";
            enum "pcap";
          }
          default "tap";
          description
            "The method to use for providing access to mirrored traffic. If set to
             <tap>, the traffic is senf to a TAP interface where it
             can be collected with standard tools (e.g. tcpdump).  If
             no explicit <name> is given, the name of the TAP inteface
             is derived from the name of the mirrored interface as
             follows: slashes are replaced by hyphens and the
             direction ('rx' ot 'tx') is appended to the end of the
             name separeted by an underscore.  The name is truncated
             at the system's limit for interface names (the IFNAMSIZ
             constant, which currently has the value 16).

             If set to <pcap>, the mirrored packets are written to a
             file in pcap format.  If no explicit <name> is given, it
             defaults to '/tmp/' followed by the name derived from the
             interface as described above with an additional '.pcap'
             appended to the final path name";
        }
        leaf name {
          type string;
          description
            "If given, overrides the names of either the TAP interface or pcap file
             as described in <type>.  The name is augmented with the suffix '_rx' or
             '_tx', depending on the direction.";
        }
      }

      leaf mtu {
        type uint16;
        mandatory true;
        description
          "The MTU of the interface including the entire L2 header (e.g. 14 bytes
           for an untagged interface, 18 bytes for a single-tagged
           interface";
      }

      uses interface-address-families;

      container trunk {
        leaf enable {
          type boolean;
          mandatory true;
          description
            "Whether to configure the interface as a VLAN trunk";
        }
        leaf encapsulation {
          default "dot1q";
          type enumeration {
            enum dot1q;
            enum dot1ad;
            enum raw;
          }
          description
            "The type of encapsulation to use in VLAN tags. This determines the
             value of the 'Tag Protocol Identifier field'. For 'dot1q'
             and 'dot1ad' the values are 0x8100 and
             0x88a8. respectively.  It is possible to chose an
             arbitrary TPID by setting the encapsulation to 'raw' and
             setting <tpid> to the desired value.";
        }
        leaf tpid {
          type uint16;
          description
            "If <encapsulation> is 'raw', this is the number that will be used as
             the 'Tag Protocol Identifier'.";
        }

        list vlan {
          description
            "A list of VLANs to be transported on the trunk.";

          key "vid";
          min-elements 1;

          leaf vid {
            type uint16 {
              range 0..4095;
            }
            mandatory true;
            description
              "The VLAN ID.";
          }
          leaf description {
            type string;
            description
              "A free-form description of the function of the interface. This string
                 appears as the <description> SNMP OID";
          }
          leaf mtu {
            type uint16;
            description
              "The MTU of the sub-interface including the L2 header.  This number can
                 be smaller than the MTU of the underlying physical
                 interface but must not exceed it.";
          }

          uses interface-address-families;

        } // vlan
      } // trunk
    } // interface

    container peers {
      description
        "Definition of peers between which transport of L2 packets can be
         established.  There must be exactly one peer in the local
         list and at least one in the remote list.  Each peer has a
         list of IPv4 or IPv6 addresses associated with it.  Unique
         pairs of local and remote addresses can be defined as
         communication channels through the transport configuration item.";

      grouping peer {
        description
          "";

        leaf name {
          type string;
          description
            "The name of the local system.";
        }

        list endpoint {
          description
            "An ipv4 or ipv6 address which can be used as an endpoint for a
             pseudowire.";

          key "name";

          leaf name {
            type string;
            description
              "The name of the endpoint. The pair of peer name and endpoint name is
               used to select the remote and local addresses for a transport.";
          }

          container address {
            description
              "The address of the endpoint, either IPv4 or IPv6.";

            choice address-by-family {
              mandatory true;
              case ipv4 {
                leaf ipv4 {
                  type inet:ipv4-address;
                  mandatory true;
                  description
                    "An IPv4 address.";
                }
              }
              case ipv6 {
                leaf ipv6 {
                  type inet:ipv6-address;
                  mandatory true;
                  description
                    "An IPv6 address.";
                }
              }
            }
          }
        }
      }

      list local {
        min-elements 1;
        max-elements 1;

        key "name";
        uses peer;
      }

      list remote {
        min-elements 1;

        key "name";
        uses peer;
      }
    }

    list transport {
      min-elements 1;
      description
        "A transport is a pair of addresses selected from the set of endpoints
         of all configured peers, with the restriction that the local
         endpoint must be selected from the local peer and the remote
         endpoint must be selected from any of the remote peers.  The
         address families of the addresses must match the address
         family chosen for the transport.";

      key "name";

      grouping endpoint-selector {
        leaf peer {
          type string;
          mandatory true;
          description
            "The name of the peer from which to select an endpoint address.";
        }
        leaf endpoint {
          type string;
          mandatory true;
          description
            "The name of the endpoint relative to the selected peer.";
        }
      }

      leaf name {
        type string;
        mandatory true;
        description
          "The name of this transport.";
      }
      leaf address-family {
        type enumeration {
          enum "ipv4";
          enum "ipv6";
        }
        mandatory true;
      }
      container local {
        description
          "The selector of an address from the local peer.";
        uses endpoint-selector;
      }
      container remote {
        description
          "The selector of an address from any of the remote peers.";
        uses endpoint-selector;
      }
      container ipsec {
        leaf enable {
          type boolean;
          default false;
          description
            "Whether to enable IPsec for this transport.";
        }
        leaf encryption-algorithm {
          type enumeration {
            enum "aes-gcm-16-icv";
          }
          default aes-gcm-16-icv;
          description
            "The encryption algorithm to use.  Currently, only aes-gcm-16-icv is
             supported";
        }
      }
    }

    list vpls {
      description
        "A list of VPLS definitions.";

      key "name";

      leaf name {
        type string;
        mandatory true;
        description
          "The name of the VPLS instance.";
      }
      leaf description {
        type string;
        description
          "A brief description of the VPLS. TODO: MIB object";
      }
      leaf mtu {
        type uint16;
        mandatory true;
        description
          "The MTU of the L2 domain provided by the VPLS.  A VPLS instance will
           fail to start unless all of its attachment circuits have a
           matching MTU.  This value is also propagated throughout the
           control-channels of the pseudowires to remote instances of
           the VPLS. A pseudowire is considered to be in a 'down'
           state operationally if the MTUs at each endpoint do not
           match.";
      }
      leaf uplink {
        type string;
        mandatory true;
        description
          "The name of the interface used as the uplink for the VPLS as it
           appears in the 'interface' list.  This is effectively a
           static route for outbound packets.";
      }

      container bridge {
        description
          "The configuration for the bridge module associated with the VPLS to
             which all pseudowires and attachment circuits are
             connected.  The bridge module will not be created if the
             VPLS only contains a single pseusowire and a single
             attachment circuit.  In that case, the pseudowire is
             connected directly to the attachment circuit.

             As a mechanism for loop prevention, the bridge enforces a
             split-horizon policy on all ports to which a pseudowire
             connects: packets arriving from a pseudowire are never
             forwarded to any other pseudowire.  As a consequence, the
             pseudowires that make up a VPLS are required to form a
             full mesh.";

        choice type {
          case flooding {
            leaf flooding {
              type empty;
              description
                "A 'flooding' bridge forwards a copy of a frame received on a port to
                   all other port, only subject to the restriction of
                   the split-horizon policy.";
            }
          }
          case learning {
            container learning {
              description
                " A 'learning' bridge behaves like a flooding bridge for multicast
                    packets and packets addressed to unknown unicast
                    destinations.  The unicast source address of each
                    incoming frame is added to the list of known
                    addresses of the ingress port such that all future
                    packets destined to that address are only
                    transmitted on that particular port.";

              container mac-table {
                description
                  "Configuration of the MAC table associated with the learning bridge.";

                leaf size {
                  type uint32;
                  default 1024;
                  description
                    "The initial size (number of entries) of the MAC address table";
                }
                leaf timeout {
                  type uint16;
                  default 600;
                  description
                    "The interval in seconds after which an inactive entry is expired from
                     the MAC address table.";
                }
                leaf verbose {
                  type boolean;
                  default false;
                  description
                    "Whether to log periodic statistics about table usage and resize
                     events.";
                }
                leaf max-occupy {
                  type decimal64;
                  default 0.4;
                  description
                    "The maximum load-factor of the hash table before automatic re-sizing
                     is initiated.  The load factor is defined as the
                     ratio of the number of occupied entries and the
                     size of the table.";
                }
              } // mac-table
            }
          }
        } // choice
      } // bridge

      list attachment-circuit {
        key "name";

        leaf name {
          type string;
          mandatory true;
          description
            "An arbitrary name that identifies this attachment circuit.";
        }
        leaf interface {
          type string;
          mandatory true;
          description
            "The name of the interface as it appears in the 'interface' list.";
        }
      }

      list pseudowire {
        key "name";

        leaf name {
          type string;
          mandatory true;
          description
            "An arbitrary name that identifies this pseudowire.";
        }

        leaf vc-id {
          type uint16;
          mandatory true;
          description
            "The VC ID associated with this pseudowire. It is used to distinguish
             pseudowires between the same pair of addresses.  In other
             words, the triple (local address, remote address, VC ID)
             must be unique among the set of all pseudowires known to
             the system. The range of valid values depends on the
             tunnel protocol, because the VC ID has to be transported
             in the tunnel header.  Certain tunnels do not support a
             VC ID at all. In that case, the vc-id parameter must be
             set to zero and the uniqueness property applies to the
             pair (local address, remote address).";
        }

        leaf transport {
          type string;
          mandatory true;
          description
            "The name of the transport to use for this pseudowire.";
        }

        container tunnel {
          description
            "The type and configuration of the tunnel protocol. Only a single
             selection is allowed.  Currently supported tunnels are
             l2tpv3 (in the flavor of 'Keyed IPv6 Tunnel', RFC 8159)
             and GRE.";

          choice tunnel-type {
            mandatory true;
            case l2tpv3 {
              container l2tpv3 {
                description
                  "The configuration of the l2tpv3 tunnel type.";

                mandatory true;
                leaf local-cookie {
                  type string;
                  default "\x00\x00\x00\x00\x00\x00\x00\x00";
                  description
                    "The value of the local cookie (expected in the header of incoming
                     packets) as a binary string of exactly 8
                     characters.  The string is evaluated as a Lua
                     string and may contain any escape sequence
                     supported by Lua.";
                }
                leaf remote-cookie {
                  type string;
                  default "\x00\x00\x00\x00\x00\x00\x00\x00";
                  description
                    "The value of the remote cookie (written to the header of outgoing
                     packets) as a binary string of exactly 8
                     characters.  The string is evaluated as a Lua
                     string and may contain any escape sequence
                     supported by Lua.";
                }
              }
            }
            case gre {
              container gre {
                presence
                  "There are no configurable elements for this tunnel type.";
                description
                  "The GRE tunnel uses the value 0x6558 (Transparent Ethernet Bridging)
                   for the protocol header field.  The key field is
                   used to transport the VC ID. Checksumming is not
                   supported.";

                leaf dummy {
                  type boolean;
                  description
                    "This optional node is ignored. It exists to work around a bug
                     in the YANG parser which doesn't recognize an empty presence container";
                }
              }
            }
          }
        } // tunnel

        container control-channel {
          description
            "The configuration of the proprietary control-channel between tunnel
               endpoints.";

          leaf enable {
            type boolean;
            default true;
            description
              "Whether to enable the control-channel for this pseudowire.";
          }
          leaf heartbeat {
            type uint16;
            default 5;
            description
              "The interval in seconds at which heartbeat messages are sent to the
                 peer.";
          }
          leaf dead-factor {
            type uint16;
            default 3;
            description
              "The number of heartbeat intervals without receiving heartbeat messages
                 after which the peer is decalred to be dead.  Like
                 the tunnel itself, the operational status of a
                 pseudowire is unidirectional.";
          }
        } // control-channel
      } // pw
    } // vpls
  } // l2vpn-config
}
